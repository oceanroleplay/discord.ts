"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6084],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>y});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),y=r,g=u["".concat(l,".").concat(y)]||u[y]||d[y]||a;return t?i.createElement(g,o(o({ref:n},p),{},{components:t})):i.createElement(g,o({ref:n},p))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<a;c++)o[c]=t[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4254:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(7462),r=(t(7294),t(3905));const a={},o="IOC support via DI",s={unversionedId:"general/dependencyInjection",id:"general/dependencyInjection",title:"IOC support via DI",description:"Discordx supports multiple DI containers to help you efficiently manage and architect large applications that wish to",source:"@site/docs/general/dependencyInjection.md",sourceDirName:"general",slug:"/general/dependencyInjection",permalink:"/docs/general/dependencyInjection",draft:!1,editUrl:"https://github.com/oceanroleplay/discord.ts/edit/main/docs/docs/general/dependencyInjection.md",tags:[],version:"current",lastUpdatedBy:"Victorique",lastUpdatedAt:1658340795,formattedLastUpdatedAt:"Jul 20, 2022",frontMatter:{},sidebar:"docSidebar",previous:{title:"Sharding",permalink:"/docs/general/sharding"},next:{title:"@Slash - Discord commands",permalink:"/docs/decorators/commands/slash"}},l={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Usage",id:"usage",level:2},{value:"Note for TSyringe using <code>tsyringeDependencyRegistryEngine</code>",id:"note-for-tsyringe-using-tsyringedependencyregistryengine",level:3},{value:"Tokenization",id:"tokenization",level:2},{value:"Getting all @Discord classes",id:"getting-all-discord-classes",level:2}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"ioc-support-via-di"},"IOC support via DI"),(0,r.kt)("p",null,"Discordx supports multiple DI containers to help you efficiently manage and architect large applications that wish to\ntake advantage of an IOC paradigm"),(0,r.kt)("p",null,"Another use for this approach is that sometimes, you will find yourself wanting to get hold of objects and instances and\nmight have been tempted to just put them on the Client, or extend the Client object with your own custom Client class\nand just put everything there. This is fine in a pure JS way, but causes issues especially with maintenance and\nmanaging, as well as having to unsafely cast your Client."),(0,r.kt)("p",null,"So, if you have a large codebase and are using one of our supported DI containers to inject dependency, Discordx can now\nutilize the container to register each annotated ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord()")," class!"),(0,r.kt)("p",null,"In order to use your container, there is some small configuration to do in your code."),(0,r.kt)("p",null,"The way that Discordx does this is my defining an engine interface ",(0,r.kt)("inlineCode",{parentName:"p"},"IDependencyRegistryEngine"),", an implementation of\nthis interface is used on the ",(0,r.kt)("inlineCode",{parentName:"p"},"DIService")," to handle the retrieval and resolution of services."),(0,r.kt)("p",null,"In order to use a custom IOC framework like Nestjs, simply implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"IDependencyRegistryEngine")," interface and set\nit on the ",(0,r.kt)("inlineCode",{parentName:"p"},"DIService")," (see below)."),(0,r.kt)("h2",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pre-configured DI containers:")),(0,r.kt)("p",null,"We have default implementations of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IDependencyRegistryEngine")," for the following frameworks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"TSyringe (",(0,r.kt)("inlineCode",{parentName:"li"},"tsyringeDependencyRegistryEngine"),")"),(0,r.kt)("li",{parentName:"ul"},"TypeDi (",(0,r.kt)("inlineCode",{parentName:"li"},"typeDiDependencyRegistryEngine"),")")),(0,r.kt)("p",null,"Before you import or define any ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord")," classes, you must bind your di engine to discordx (Whether imported\nfrom ",(0,r.kt)("inlineCode",{parentName:"p"},"importx")," or another custom loader). To accomplish this, simply add ",(0,r.kt)("inlineCode",{parentName:"p"},"DIService.engine = implemntation")," before the\naforementioned importer, As shown in the examples below."),(0,r.kt)("p",null,"In the case of ",(0,r.kt)("inlineCode",{parentName:"p"},"tsyringeDependencyRegistryEngine")," because of how shared containers work, you MUST set the container\nreference from your side."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TSyringe"',title:'"TSyringe"'},'import { container } from "tsyringe";\nimport { DIService, tsyringeDependencyRegistryEngine } from "discordx";\n\nDIService.engine = tsyringeDependencyRegistryEngine.setInjector(container); // set the container\n')),(0,r.kt)("p",null,"For TypeDi, both the service Method and the container must be set"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TypeDi"',title:'"TypeDi"'},'import { DIService, typeDiDependencyRegistryEngine } from "discordx";\nimport { Container, Service } from "typedi";\n\nDIService.engine = typeDiDependencyRegistryEngine\n  .setService(Service)\n  .setInjector(Container);\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="customEngine"',title:'"customEngine"'},'import { DIService } from "discordx";\nimport { Container } from "typedi";\nimport { myCustomEngine } from "./MyCustomEngine.js";\n\nDIService.engine = myCustomEngine;\n')),(0,r.kt)("p",null,"It is recommended to do this in your main class where you define your ",(0,r.kt)("inlineCode",{parentName:"p"},"new Client()")," code; for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import "reflect-metadata";\nimport { IntentsBitField } from "discord.js";\nimport { Intents } from "discord.js";\nimport { Client, DIService, tsyringeDependencyRegistryEngine } from "discordx";\n\nasync function start() {\n  DIService.engine = tsyringeDependencyRegistryEngine;\n  const client = new Client({\n    botId: "test",\n    intents: [\n      IntentsBitField.Flags.Guilds,\n      IntentsBitField.Flags.GuildMessages,\n    ],\n    silent: false,\n  });\n\n  await client.login("YOUR_TOKEN");\n}\n\nstart();\n')),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,"Once you have told Discordx to use your engine for DI, it will then ask your engine for all the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord()")," services\nwhen it needs to both register and retrieve them."),(0,r.kt)("h3",{id:"note-for-tsyringe-using-tsyringedependencyregistryengine"},"Note for TSyringe using ",(0,r.kt)("inlineCode",{parentName:"h3"},"tsyringeDependencyRegistryEngine")),(0,r.kt)("p",null,"If you are using our ",(0,r.kt)("inlineCode",{parentName:"p"},"tsyringeDependencyRegistryEngine")," for TSyringe classes declared with ",(0,r.kt)("inlineCode",{parentName:"p"},"@singleton()")," are\nautomatically ",(0,r.kt)("inlineCode",{parentName:"p"},"@injectable()")," but in Discordx you must add this annotation too if you wish your classes to receive\nconstructor injection."),(0,r.kt)("p",null,"For example, say you have a Database class you wish to inject into your declared ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord()")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@singleton()\nclass Database {\n  database: string;\n\n  constructor() {\n    console.log("I am database");\n    this.database = "connected";\n  }\n\n  query() {\n    return this.database;\n  }\n}\n')),(0,r.kt)("p",null,"In order to get this class injected into your ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord()")," instance at runtime, you must define your class as\nboth ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord()")," ",(0,r.kt)("strong",{parentName:"p"},"AND")," ",(0,r.kt)("inlineCode",{parentName:"p"},"@injectable()"),": (the order is important)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Discord()\n@injectable()\nclass Example {\n  constructor(private _database: Database) {\n    console.log("constructed me as a singleton and injected _database");\n  }\n\n  @Slash("tsyringe")\n  private tsyringe(interaction: CommandInteraction): void {\n    if (DIService.container) {\n      // resolve class\n      const clazz = container.resolve(Example);\n\n      // respond with class test\n      interaction.reply(\n        `${clazz._database.query()}, same class: ${clazz === this}`\n      );\n    } else {\n      // warn: TSyringe is not used\n      interaction.reply("Not using TSyringe");\n    }\n  }\n}\n')),(0,r.kt)("p",null,"When running the above code, your ",(0,r.kt)("inlineCode",{parentName:"p"},"database")," will be injected into your ",(0,r.kt)("inlineCode",{parentName:"p"},"Example")," class and when you ask your container\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"Example")," you always receive the same instance of the class ",(0,r.kt)("inlineCode",{parentName:"p"},"container.resolve(Example);")),(0,r.kt)("p",null,"If you do not mark the class as ",(0,r.kt)("inlineCode",{parentName:"p"},"@injectable()")," you will get an error thrown from TSyringe telling you where is no type\ninfo for your class."),(0,r.kt)("p",null,"For TypeDI using the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDiDependencyRegistryEngine"),", you do not need to mark your classes, all DI works as expected,\nalong with ",(0,r.kt)("inlineCode",{parentName:"p"},"@Inject")," for props and constructor overrides with other services."),(0,r.kt)("h2",{id:"tokenization"},"Tokenization"),(0,r.kt)("p",null,"the ",(0,r.kt)("inlineCode",{parentName:"p"},"tsyringeDependencyRegistryEngine")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDiDependencyRegistryEngine")," both by can register all the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord"),"\nservices with tokens, the tokens are available by static props on the classes:\ne.g ",(0,r.kt)("inlineCode",{parentName:"p"},"tsyringeDependencyRegistryEngine.token"),"."),(0,r.kt)("p",null,"This means that in order to get a class from the container of these, you will need to supply a token or\ncall ",(0,r.kt)("inlineCode",{parentName:"p"},"DIService.instance.getService(DiscordService);"),"."),(0,r.kt)("p",null,"Because of thw way that TypeDI and tsyringe deals with tokens, if you simply inject a ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord")," class it will create a\nNEW instance of that class, and it will not be a singleton, this is because any class registered with a token can only\nbe retrieved with that token."),(0,r.kt)("p",null,"So, by default, tokens on TypeDI and tsyringe are disabled, to enable them,\ncall ",(0,r.kt)("inlineCode",{parentName:"p"},"tsyringeDependencyRegistryEngine.setUseTokenization(true);"),"\nor ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDiDependencyRegistryEngine.setUseTokenization(true);")),(0,r.kt)("p",null,"If you enable tokens on tsyringe or TypeDI, it would mean that you would have to use ",(0,r.kt)("inlineCode",{parentName:"p"},"@InjectAll")," then do a filter on\nthat array to find the class."),(0,r.kt)("p",null,"For example, if you wanted to get the ",(0,r.kt)("inlineCode",{parentName:"p"},"OnReady.ts")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="useTokenization=true"',title:'"useTokenization'},'@Discord()\nclass OnReady {\n  private bar = "bar";\n  public foo() {\n    console.log(this.bar);\n  }\n}\n\n@injectable()\nclass TsClass {\n  private onReady: OnReady | null;\n\n  public constructor(\n    @injectAll(tsyringeDependencyRegistryEngine.token) discordClasses: unknown[]\n  ) {\n    this.onReady =\n      discordClasses.find((service) => service.constructor === OnReady) ?? null;\n    // or\n    this.onReady = DIService.getService(OnReady);\n\n    this.onReady.foo();\n  }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="useTokenization=false"',title:'"useTokenization'},'@Discord()\nclass OnReady {\n  private bar = "bar";\n  public foo() {\n    console.log(this.bar);\n  }\n}\n\n@injectable()\nclass TsClass {\n  public constructor(private onReady: OnReady) {\n    onReady.foo();\n  }\n}\n')),(0,r.kt)("h2",{id:"getting-all-discord-classes"},"Getting all @Discord classes"),(0,r.kt)("p",null,"If for some reason, you wish to get all instances of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Discord")," classes in your bot, then you can simple\ncall ",(0,r.kt)("inlineCode",{parentName:"p"},"DIService.getAllServices();")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE"),": this will construct all your classes in the DI container, if you wish to lazy-load your Discord classes, then\nyou can not do this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { DIService } from "discordx";\n\nfunction getAllDiscordClasses(): Set<unknown> {\n  return DIService.getAllServices();\n}\n')))}d.isMDXComponent=!0}}]);